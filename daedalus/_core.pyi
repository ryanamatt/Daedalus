"""
Daedalus: A Machine Learning library
"""
from __future__ import annotations
import collections.abc
import typing
__all__: list[str] = ['DataFrame', 'KNN', 'LinearRegression', 'LogisticRegression', 'Matrix', 'NeuralNetwork', 'StandardScaler', 'accuracy_score', 'f1_score', 'mean_squared_error', 'precision_score', 'r2_score', 'read_csv', 'recall_score', 'train_test_split']
class DataFrame:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, col_name: str, col_data: collections.abc.Sequence[typing.SupportsFloat | typing.SupportsIndex | typing.SupportsInt | typing.SupportsIndex | str]) -> None:
        """
        Constructs a DataFrame with an initial column.
        """
    def __repr__(self) -> str:
        ...
    def add_column(self, name: str, col_data: collections.abc.Sequence[typing.SupportsFloat | typing.SupportsIndex | typing.SupportsInt | typing.SupportsIndex | str]) -> None:
        ...
    @typing.overload
    def at(self, row: typing.SupportsInt | typing.SupportsIndex, col_name: str) -> float | int | str:
        ...
    @typing.overload
    def at(self, row: typing.SupportsInt | typing.SupportsIndex, col: typing.SupportsInt | typing.SupportsIndex) -> float | int | str:
        ...
    def drop_column(self, name: str) -> None:
        ...
    def encode_binary(self, column_name: str, val0: str = '', val1: str = '') -> None:
        ...
    def filter(self, col_name: str, predicate: collections.abc.Callable) -> DataFrame:
        """
        Filters rows using a Python lambda or function.
        """
    def get_column_names(self) -> list[str]:
        ...
    def head(self, n: typing.SupportsInt | typing.SupportsIndex = 5) -> DataFrame:
        """
        Returns the first n rows of the DataFrame.
        """
    def to_matrix(self, target_columns: collections.abc.Sequence[str]) -> Matrix:
        ...
    @property
    def cols(self) -> int:
        ...
    @property
    def rows(self) -> int:
        ...
class KNN:
    def __init__(self, k: typing.SupportsInt | typing.SupportsIndex = 3) -> None:
        ...
    def fit(self, X: Matrix, y: Matrix) -> None:
        ...
    def predict(self, X: Matrix) -> Matrix:
        ...
class LinearRegression:
    def __init__(self, learning_rate: typing.SupportsFloat | typing.SupportsIndex = 0.01, reg_lambda: typing.SupportsFloat | typing.SupportsIndex = 0.01, penalty: str = 'none') -> None:
        ...
    @typing.overload
    def fit(self, X: Matrix, y: Matrix) -> None:
        ...
    @typing.overload
    def fit(self, X: Matrix, y: Matrix, epochs: typing.SupportsInt | typing.SupportsIndex) -> None:
        ...
    def load_model(self, filename: str) -> None:
        ...
    def predict(self, X: Matrix) -> Matrix:
        ...
    def save_model(self, filename: str) -> None:
        ...
class LogisticRegression:
    def __init__(self, learning_rate: typing.SupportsFloat | typing.SupportsIndex = 0.01, reg_lambda: typing.SupportsFloat | typing.SupportsIndex = 0.01, penalty: str = 'none') -> None:
        ...
    @typing.overload
    def fit(self, X: Matrix, y: Matrix) -> None:
        ...
    @typing.overload
    def fit(self, X: Matrix, y: Matrix, epochs: typing.SupportsInt | typing.SupportsIndex) -> None:
        ...
    def load_model(self, filename: str) -> None:
        ...
    def predict(self, X: Matrix) -> Matrix:
        ...
    def predict_proba(self, X: Matrix) -> Matrix:
        ...
    def save_model(self, filename: str) -> None:
        ...
class Matrix:
    def __add__(self, arg0: Matrix) -> Matrix:
        ...
    def __call__(self, r: typing.SupportsInt | typing.SupportsIndex, c: typing.SupportsInt | typing.SupportsIndex) -> float:
        ...
    def __getitem__(self, arg0: typing.Any) -> typing.Any:
        ...
    def __init__(self, arg0: typing.SupportsInt | typing.SupportsIndex, arg1: typing.SupportsInt | typing.SupportsIndex) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix) -> Matrix:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat | typing.SupportsIndex) -> Matrix:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat | typing.SupportsIndex) -> Matrix:
        ...
    def __setitem__(self, arg0: tuple, arg1: typing.SupportsFloat | typing.SupportsIndex) -> None:
        ...
    def __sub__(self, arg0: Matrix) -> Matrix:
        ...
    def get_row(self, idx: typing.SupportsInt | typing.SupportsIndex) -> Matrix:
        ...
    def set(self, r: typing.SupportsInt | typing.SupportsIndex, c: typing.SupportsInt | typing.SupportsIndex, val: typing.SupportsFloat | typing.SupportsIndex) -> None:
        ...
    def transpose(self) -> Matrix:
        ...
    @property
    def cols(self) -> int:
        ...
    @property
    def rows(self) -> int:
        ...
class NeuralNetwork:
    def __init__(self, lr: typing.SupportsFloat | typing.SupportsIndex = 0.01) -> None:
        ...
    def add(self, arg0: typing.SupportsInt | typing.SupportsIndex, arg1: typing.SupportsInt | typing.SupportsIndex) -> None:
        ...
    @typing.overload
    def fit(self, X: Matrix, y: Matrix) -> None:
        ...
    @typing.overload
    def fit(self, X: Matrix, y: Matrix, epochs: typing.SupportsInt | typing.SupportsIndex) -> None:
        ...
    def predict(self, X: Matrix) -> Matrix:
        ...
class StandardScaler:
    def __init__(self) -> None:
        ...
    def fit(self, X: Matrix) -> None:
        ...
    def fit_transform(self, X: Matrix) -> Matrix:
        ...
    def transform(self, X: Matrix) -> Matrix:
        ...
def accuracy_score(y_true: Matrix, y_pred: Matrix) -> float:
    ...
def f1_score(y_true: Matrix, y_pred: Matrix) -> float:
    ...
def mean_squared_error(y_true: Matrix, y_pred: Matrix) -> float:
    """
    Calculates Mean Squared Error
    """
def precision_score(y_true: Matrix, y_pred: Matrix) -> float:
    ...
def r2_score(y_true: Matrix, y_pred: Matrix) -> float:
    """
    Calculates R-Squared Score
    """
def read_csv(filename: str, has_header: bool = True) -> DataFrame:
    ...
def recall_score(y_true: Matrix, y_pred: Matrix) -> float:
    ...
def train_test_split(X: Matrix, y: Matrix, test_size: typing.SupportsFloat | typing.SupportsIndex = 0.2, seed: typing.SupportsInt | typing.SupportsIndex = 42) -> tuple[Matrix, Matrix, Matrix, Matrix]:
    """
    Splits features and targets into training and testing sets.
    """
